# 前缀和&差分笔记

前缀和理解为数列前n项和,差分理解为使用数列前n项和与数列前n-1项和求数列第n项

## 一维前缀和

直接遍历数列相加即可,做法同高中数列,特殊数列可利用公式,同时应记得等差等比数列的二级结论与其前n项和的二级结论

## 二维前缀和

假设A[3][3]={x1,x2,x3,x4,x5,x6,x7,x8,x9}是一个3*3二维数组,使用集合的容斥原理(https://baike.baidu.com/item/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/10146840)有如下公式

$S_{i,j}$=$A_{i,j}$+$S_{i-1,j}$+$S_{i,j-1}$-$S_{i-1,j-1}$

其中i和j分别代表数组A的维,$S_{i,j}$(即这个公式求得的数)代表了将每个A数组的下标都加到i和j本身(不大于其)

这个公式实际操作起来有如下直观意义:

```
   x1 x2 x3
A={x4 x5 x6}
   x7 x8 x9
```

得到一个数列S[3][3]如下

```
   x1       x1+x2                            x1+x2+x3
S={x1+x4    x1+x2+x1+x4+x5-x1                x1+x2+x3+x1+x2+x1+x4+x5+x6-x1-x2                                          }
   x1+x4+x7 x1+x2+x1+x4+x5+x1+x4+x7+x8-x1-x4 x1+x2+x3+x1+x2+x1+x4+x5+x6+x1+x2+x1+x4+x5+x1+x4+x7+x8+x9-x1-x2-x1-x4-x5+x1
```

(建议长屏查看markdown)

语言表述,就是对于行首和列首的元素,进行一维前缀和相加(普通数列求和)

对于其他不在行首和列首的元素,其有:以其正上方的元素和左边的元素相加,再加上A数组内同位置的元素,减去其左上角的元素,得到该位置元素

这样可以正好得到将A数组的元素相加到被加元素的下标不大于该位置的下标

对于A数组的子数组(左上角下标为i1,j1,右下角下标为i2,j2)之和,有

$S_{i2,j2}$-$S_{i1,j2}$-$S_{i2,j1}$+$S_{i1,j1}$

直观意义上,其代表了如下意义,以下是一个二维原数组A

```
1 2 3 4
5 6 7 8
a b c d
e f g h
```

假设求c+d+g+h,该公式代表了先将整个二维数组相加一遍,然后减去12345678,减去1256abef,再加上1256

***

问:既然S的每个元素是将每个A数组的下标都加到i和j本身(不大于其)得到的,为什么不能用for循环将下标遍历?

答:因为那样只能求单个S,不能求整个A数列的前缀和

***

二位前缀和程序:对于一个原二维数组A,二位前缀和数组S,对A有(其中n和m为数组边界,时间复杂度为O(nm))

```
int i;
int j;
for (i = 1; i <= n; i++)
{
    for (j = 1; j <= m; j++)
    {
        S[i][j] = S[i][j - 1] + S[i - 1][j] - S[i - 1][j - 1] + A[i][j];
    }
}
```

得到二维前缀和数组S,注意,i和j初始化为1,不是0,因为它并不是一般的遍历数组,而是二维前缀和算法

也应注意,行首和列首的S元素在这个程序中已经被初始化了,不必再自己处理

***

遍历子数组的程序:

```
int c[83] = { 0 };
int d = 0;
while (l <= min(n, m))
{
    for (int i = l; i <= n; i++)
    {
        for (int j = l; j <= m; j++)
        {
            c[d] = S[i][j] - S[i - l][j] - S[i][j - l] + S[i - l][j - l];
        }
    }
    l++;
}
```

这个程序中,c数组装的是二维差分数组S原数组的子数组之和

while的作用是防止子数组的行(或列)比原数组的行(或列)还大,没其他别的什么用,不会导致漏掉哪个子数组

***

典例:https://www.luogu.com.cn/problem/P1387

思路:遍历所有子数组,如果子数列的和为1、4、9……(即正整数的平方)说明子数组是正方形(这步是关键,遍历所有子数组,但是以正整数的平方筛选出正方形),擂台法比较即可

## 一维差分

直接使用数列的前n项和减去数列的前n-1项和即可

## 二维差分

略,其实求子数组就是一种大的差分,现在所说的差分只是求只有一个元素的子数组罢了